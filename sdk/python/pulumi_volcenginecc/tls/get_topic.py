# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'GetTopicResult',
    'AwaitableGetTopicResult',
    'get_topic',
    'get_topic_output',
]

@pulumi.output_type
class GetTopicResult:
    """
    A collection of values returned by getTopic.
    """
    def __init__(__self__, archive_ttl=None, auto_split=None, cold_ttl=None, created_time=None, description=None, enable_hot_ttl=None, enable_tracking=None, hot_ttl=None, id=None, log_public_ip=None, max_split_shard=None, project_id=None, shard_count=None, tags=None, time_format=None, time_key=None, topic_id=None, topic_name=None, ttl=None, updated_time=None):
        if archive_ttl and not isinstance(archive_ttl, int):
            raise TypeError("Expected argument 'archive_ttl' to be a int")
        pulumi.set(__self__, "archive_ttl", archive_ttl)
        if auto_split and not isinstance(auto_split, bool):
            raise TypeError("Expected argument 'auto_split' to be a bool")
        pulumi.set(__self__, "auto_split", auto_split)
        if cold_ttl and not isinstance(cold_ttl, int):
            raise TypeError("Expected argument 'cold_ttl' to be a int")
        pulumi.set(__self__, "cold_ttl", cold_ttl)
        if created_time and not isinstance(created_time, str):
            raise TypeError("Expected argument 'created_time' to be a str")
        pulumi.set(__self__, "created_time", created_time)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if enable_hot_ttl and not isinstance(enable_hot_ttl, bool):
            raise TypeError("Expected argument 'enable_hot_ttl' to be a bool")
        pulumi.set(__self__, "enable_hot_ttl", enable_hot_ttl)
        if enable_tracking and not isinstance(enable_tracking, bool):
            raise TypeError("Expected argument 'enable_tracking' to be a bool")
        pulumi.set(__self__, "enable_tracking", enable_tracking)
        if hot_ttl and not isinstance(hot_ttl, int):
            raise TypeError("Expected argument 'hot_ttl' to be a int")
        pulumi.set(__self__, "hot_ttl", hot_ttl)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if log_public_ip and not isinstance(log_public_ip, bool):
            raise TypeError("Expected argument 'log_public_ip' to be a bool")
        pulumi.set(__self__, "log_public_ip", log_public_ip)
        if max_split_shard and not isinstance(max_split_shard, int):
            raise TypeError("Expected argument 'max_split_shard' to be a int")
        pulumi.set(__self__, "max_split_shard", max_split_shard)
        if project_id and not isinstance(project_id, str):
            raise TypeError("Expected argument 'project_id' to be a str")
        pulumi.set(__self__, "project_id", project_id)
        if shard_count and not isinstance(shard_count, int):
            raise TypeError("Expected argument 'shard_count' to be a int")
        pulumi.set(__self__, "shard_count", shard_count)
        if tags and not isinstance(tags, list):
            raise TypeError("Expected argument 'tags' to be a list")
        pulumi.set(__self__, "tags", tags)
        if time_format and not isinstance(time_format, str):
            raise TypeError("Expected argument 'time_format' to be a str")
        pulumi.set(__self__, "time_format", time_format)
        if time_key and not isinstance(time_key, str):
            raise TypeError("Expected argument 'time_key' to be a str")
        pulumi.set(__self__, "time_key", time_key)
        if topic_id and not isinstance(topic_id, str):
            raise TypeError("Expected argument 'topic_id' to be a str")
        pulumi.set(__self__, "topic_id", topic_id)
        if topic_name and not isinstance(topic_name, str):
            raise TypeError("Expected argument 'topic_name' to be a str")
        pulumi.set(__self__, "topic_name", topic_name)
        if ttl and not isinstance(ttl, int):
            raise TypeError("Expected argument 'ttl' to be a int")
        pulumi.set(__self__, "ttl", ttl)
        if updated_time and not isinstance(updated_time, str):
            raise TypeError("Expected argument 'updated_time' to be a str")
        pulumi.set(__self__, "updated_time", updated_time)

    @property
    @pulumi.getter(name="archiveTtl")
    def archive_ttl(self) -> builtins.int:
        """
        归档存储时长。该时长取值范围为 60~3650。满足如下任一条件时，可实现归档存储。标准存储时长 30 天及以上。标准存储时长 7 天及以上且低频存储时长 30 天及以上。此参数仅在 EnableHotTtl 为 true 时生效。
        """
        return pulumi.get(self, "archive_ttl")

    @property
    @pulumi.getter(name="autoSplit")
    def auto_split(self) -> builtins.bool:
        """
        是否开启分区的自动分裂功能。true：当写入的数据量连续 5 分钟超过已有分区服务能力时，日志服务会根据数据量自动分裂分区以满足业务需求，但分裂后的分区数量不可超出最大分裂数。最近 15 分钟内分裂出来的新分区不会自动分裂。false：不开启分区的自动分裂。
        """
        return pulumi.get(self, "auto_split")

    @property
    @pulumi.getter(name="coldTtl")
    def cold_ttl(self) -> builtins.int:
        """
        低频存储时长。该时长取值范围为 30~3650。标准存储时长 7 天及以上可实现低频存储。此参数仅在 EnableHotTtl 为 true 时生效。
        """
        return pulumi.get(self, "cold_ttl")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> builtins.str:
        """
        日志主题创建时间。
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        日志主题描述信息。不支持 <>、'、\\、\\、所有 emoji 表情符号。长度为 0~64 个字符。
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableHotTtl")
    def enable_hot_ttl(self) -> builtins.bool:
        """
        是否开启分层存储。开启后，日志服务支持标准存储、低频存储和归档存储。设置 HotTtl、ArchiveTtl、ColdTtl 后，如果数据存储时间超过对应时长，那么数据会自动沉降至低频存储、归档存储进行后续保存，直到日志采集到服务端的总时长达到 Ttl 时，被后端服务自动清理。
        """
        return pulumi.get(self, "enable_hot_ttl")

    @property
    @pulumi.getter(name="enableTracking")
    def enable_tracking(self) -> builtins.bool:
        """
        是否开启 WebTracking 功能，开启后，可以通过 WebTracking 快速采集前端埋点数据。true：开启 WebTracking功能。false：（默认）关闭 WebTracking 功能。为日志主题开启 Web Tracking 后，通过 API 接口 WebTracks 写入数据时无需经过鉴权，相当于面向公网开放了匿名写入权限，可能产生脏数据。
        """
        return pulumi.get(self, "enable_tracking")

    @property
    @pulumi.getter(name="hotTtl")
    def hot_ttl(self) -> builtins.int:
        """
        标准存储时长。该时长默认为 30 天，取值范围为 7~3650。此参数仅在 EnableHotTtl 为 true 时生效。
        """
        return pulumi.get(self, "hot_ttl")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Uniquely identifies the resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="logPublicIp")
    def log_public_ip(self) -> builtins.bool:
        """
        是否开启记录外网 IP 功能。默认为开启状态。开启后日志服务会自动在日志内容中添加以下元数据字段。**tag****client_ip**：日志来源设备的公网 IP 地址。使用日志服务的私网域名写入日志数据时，则记录私网 IP 地址。**tag****receive_time**：日志达到服务端的时间，格式为 10 位的 Unixtime 时间戳。
        """
        return pulumi.get(self, "log_public_ip")

    @property
    @pulumi.getter(name="maxSplitShard")
    def max_split_shard(self) -> builtins.int:
        """
        分区的最大分裂数，即分区分裂后，所有分区的最大数量。取值范围为 1~256，默认为 256。仅在开启自动分裂日志分区，即 AutoSplit 为 true 时必选。MaxSplitShard 必须大于指定的 ShardCount，否则日志服务无法自动分裂分区。
        """
        return pulumi.get(self, "max_split_shard")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> builtins.str:
        """
        日志主题所属的日志项目 ID。
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="shardCount")
    def shard_count(self) -> builtins.int:
        """
        日志分区的数量，默认创建 1 个分区，取值范围为 1～10。 每个分区提供的写入能力为 5MiB/s、500 次/s，读取能力为 20 MiB/s、100 次/s。请在创建日志主题时合理规划分区，创建后暂不支持修改分区数量。
        """
        return pulumi.get(self, "shard_count")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetTopicTagResult']:
        """
        标签列表。
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> builtins.str:
        """
        时间格式
        """
        return pulumi.get(self, "time_format")

    @property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> builtins.str:
        """
        时间字段名
        """
        return pulumi.get(self, "time_key")

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> builtins.str:
        """
        日志主题 ID。
        """
        return pulumi.get(self, "topic_id")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> builtins.str:
        """
        日志主题名称。
        """
        return pulumi.get(self, "topic_name")

    @property
    @pulumi.getter
    def ttl(self) -> builtins.int:
        """
        日志在日志服务中的总保存时间，超过指定的日志存储时长后，此日志主题中的过期日志会被自动清除。单位为天，默认为 30 天。取值范围为 1～3650，指定为 3650 天表示永久存储。
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter(name="updatedTime")
    def updated_time(self) -> builtins.str:
        """
        日志主题修改时间。
        """
        return pulumi.get(self, "updated_time")


class AwaitableGetTopicResult(GetTopicResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetTopicResult(
            archive_ttl=self.archive_ttl,
            auto_split=self.auto_split,
            cold_ttl=self.cold_ttl,
            created_time=self.created_time,
            description=self.description,
            enable_hot_ttl=self.enable_hot_ttl,
            enable_tracking=self.enable_tracking,
            hot_ttl=self.hot_ttl,
            id=self.id,
            log_public_ip=self.log_public_ip,
            max_split_shard=self.max_split_shard,
            project_id=self.project_id,
            shard_count=self.shard_count,
            tags=self.tags,
            time_format=self.time_format,
            time_key=self.time_key,
            topic_id=self.topic_id,
            topic_name=self.topic_name,
            ttl=self.ttl,
            updated_time=self.updated_time)


def get_topic(id: Optional[builtins.str] = None,
              opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetTopicResult:
    """
    Data Source schema for Volcengine::TLS::Topic


    :param builtins.str id: Uniquely identifies the resource.
    """
    __args__ = dict()
    __args__['id'] = id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('volcenginecc:tls/getTopic:getTopic', __args__, opts=opts, typ=GetTopicResult).value

    return AwaitableGetTopicResult(
        archive_ttl=pulumi.get(__ret__, 'archive_ttl'),
        auto_split=pulumi.get(__ret__, 'auto_split'),
        cold_ttl=pulumi.get(__ret__, 'cold_ttl'),
        created_time=pulumi.get(__ret__, 'created_time'),
        description=pulumi.get(__ret__, 'description'),
        enable_hot_ttl=pulumi.get(__ret__, 'enable_hot_ttl'),
        enable_tracking=pulumi.get(__ret__, 'enable_tracking'),
        hot_ttl=pulumi.get(__ret__, 'hot_ttl'),
        id=pulumi.get(__ret__, 'id'),
        log_public_ip=pulumi.get(__ret__, 'log_public_ip'),
        max_split_shard=pulumi.get(__ret__, 'max_split_shard'),
        project_id=pulumi.get(__ret__, 'project_id'),
        shard_count=pulumi.get(__ret__, 'shard_count'),
        tags=pulumi.get(__ret__, 'tags'),
        time_format=pulumi.get(__ret__, 'time_format'),
        time_key=pulumi.get(__ret__, 'time_key'),
        topic_id=pulumi.get(__ret__, 'topic_id'),
        topic_name=pulumi.get(__ret__, 'topic_name'),
        ttl=pulumi.get(__ret__, 'ttl'),
        updated_time=pulumi.get(__ret__, 'updated_time'))
def get_topic_output(id: Optional[pulumi.Input[builtins.str]] = None,
                     opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetTopicResult]:
    """
    Data Source schema for Volcengine::TLS::Topic


    :param builtins.str id: Uniquely identifies the resource.
    """
    __args__ = dict()
    __args__['id'] = id
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('volcenginecc:tls/getTopic:getTopic', __args__, opts=opts, typ=GetTopicResult)
    return __ret__.apply(lambda __response__: GetTopicResult(
        archive_ttl=pulumi.get(__response__, 'archive_ttl'),
        auto_split=pulumi.get(__response__, 'auto_split'),
        cold_ttl=pulumi.get(__response__, 'cold_ttl'),
        created_time=pulumi.get(__response__, 'created_time'),
        description=pulumi.get(__response__, 'description'),
        enable_hot_ttl=pulumi.get(__response__, 'enable_hot_ttl'),
        enable_tracking=pulumi.get(__response__, 'enable_tracking'),
        hot_ttl=pulumi.get(__response__, 'hot_ttl'),
        id=pulumi.get(__response__, 'id'),
        log_public_ip=pulumi.get(__response__, 'log_public_ip'),
        max_split_shard=pulumi.get(__response__, 'max_split_shard'),
        project_id=pulumi.get(__response__, 'project_id'),
        shard_count=pulumi.get(__response__, 'shard_count'),
        tags=pulumi.get(__response__, 'tags'),
        time_format=pulumi.get(__response__, 'time_format'),
        time_key=pulumi.get(__response__, 'time_key'),
        topic_id=pulumi.get(__response__, 'topic_id'),
        topic_name=pulumi.get(__response__, 'topic_name'),
        ttl=pulumi.get(__response__, 'ttl'),
        updated_time=pulumi.get(__response__, 'updated_time')))
