// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.volcengine.volcenginecc.vedbm.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.volcengine.volcenginecc.vedbm.inputs.InstanceEndpointAddressArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class InstanceEndpointArgs extends com.pulumi.resources.ResourceArgs {

    public static final InstanceEndpointArgs Empty = new InstanceEndpointArgs();

    @Import(name="addresses")
    private @Nullable Output<List<InstanceEndpointAddressArgs>> addresses;

    public Optional<Output<List<InstanceEndpointAddressArgs>>> addresses() {
        return Optional.ofNullable(this.addresses);
    }

    /**
     * 是否允许自动加入新节点，取值：true：是。false：否。
     * 
     */
    @Import(name="autoAddNewNodes")
    private @Nullable Output<Boolean> autoAddNewNodes;

    /**
     * @return 是否允许自动加入新节点，取值：true：是。false：否。
     * 
     */
    public Optional<Output<Boolean>> autoAddNewNodes() {
        return Optional.ofNullable(this.autoAddNewNodes);
    }

    /**
     * 一致性级别，仅对读写模式的连接终端有效。取值：Eventual：最终一致性。Session：会话一致性。Global：全局一致性。
     * 
     */
    @Import(name="consistLevel")
    private @Nullable Output<String> consistLevel;

    /**
     * @return 一致性级别，仅对读写模式的连接终端有效。取值：Eventual：最终一致性。Session：会话一致性。Global：全局一致性。
     * 
     */
    public Optional<Output<String>> consistLevel() {
        return Optional.ofNullable(this.consistLevel);
    }

    /**
     * 延迟很大时，只读节点同步最新数据的超时时间，单位为 us，取值范围为 1us~100000000us。
     * 
     */
    @Import(name="consistTimeout")
    private @Nullable Output<Integer> consistTimeout;

    /**
     * @return 延迟很大时，只读节点同步最新数据的超时时间，单位为 us，取值范围为 1us~100000000us。
     * 
     */
    public Optional<Output<Integer>> consistTimeout() {
        return Optional.ofNullable(this.consistTimeout);
    }

    /**
     * 只读节点同步数据超时后的超时策略，支持以下两种策略：ReturnError：返回 SQL 报错（wait replication complete timeout, please retry）。ReadMaster：发送请求到主节点。
     * 
     */
    @Import(name="consistTimeoutAction")
    private @Nullable Output<String> consistTimeoutAction;

    /**
     * @return 只读节点同步数据超时后的超时策略，支持以下两种策略：ReturnError：返回 SQL 报错（wait replication complete timeout, please retry）。ReadMaster：发送请求到主节点。
     * 
     */
    public Optional<Output<String>> consistTimeoutAction() {
        return Optional.ofNullable(this.consistTimeoutAction);
    }

    /**
     * 地址描述。
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return 地址描述。
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * 是否开启事务拆分，仅对读写模式的连接终端有效。取值：true：是。false：否。
     * 
     */
    @Import(name="distributedTransaction")
    private @Nullable Output<Boolean> distributedTransaction;

    /**
     * @return 是否开启事务拆分，仅对读写模式的连接终端有效。取值：true：是。false：否。
     * 
     */
    public Optional<Output<Boolean>> distributedTransaction() {
        return Optional.ofNullable(this.distributedTransaction);
    }

    /**
     * 实例连接终端 ID。
     * 
     */
    @Import(name="endpointId")
    private @Nullable Output<String> endpointId;

    /**
     * @return 实例连接终端 ID。
     * 
     */
    public Optional<Output<String>> endpointId() {
        return Optional.ofNullable(this.endpointId);
    }

    /**
     * 实例连接终端名称。
     * 
     */
    @Import(name="endpointName")
    private @Nullable Output<String> endpointName;

    /**
     * @return 实例连接终端名称。
     * 
     */
    public Optional<Output<String>> endpointName() {
        return Optional.ofNullable(this.endpointName);
    }

    /**
     * 连接终端类型，取值：Cluster：默认终端。Primary：主节点终端。Custom：自定义终端。
     * 
     */
    @Import(name="endpointType")
    private @Nullable Output<String> endpointType;

    /**
     * @return 连接终端类型，取值：Cluster：默认终端。Primary：主节点终端。Custom：自定义终端。
     * 
     */
    public Optional<Output<String>> endpointType() {
        return Optional.ofNullable(this.endpointType);
    }

    /**
     * 主节点是否接受读请求。仅对读写模式的连接终端有效。true：是。false：否。
     * 
     */
    @Import(name="masterAcceptReadRequests")
    private @Nullable Output<Boolean> masterAcceptReadRequests;

    /**
     * @return 主节点是否接受读请求。仅对读写模式的连接终端有效。true：是。false：否。
     * 
     */
    public Optional<Output<Boolean>> masterAcceptReadRequests() {
        return Optional.ofNullable(this.masterAcceptReadRequests);
    }

    /**
     * 连接终端配置的节点列表。
     * 
     */
    @Import(name="nodeIds")
    private @Nullable Output<List<String>> nodeIds;

    /**
     * @return 连接终端配置的节点列表。
     * 
     */
    public Optional<Output<List<String>>> nodeIds() {
        return Optional.ofNullable(this.nodeIds);
    }

    /**
     * 连接终端的读写模式，取值：ReadWrite: 读写。ReadOnly: 只读。
     * 
     */
    @Import(name="readWriteMode")
    private @Nullable Output<String> readWriteMode;

    /**
     * @return 连接终端的读写模式，取值：ReadWrite: 读写。ReadOnly: 只读。
     * 
     */
    public Optional<Output<String>> readWriteMode() {
        return Optional.ofNullable(this.readWriteMode);
    }

    private InstanceEndpointArgs() {}

    private InstanceEndpointArgs(InstanceEndpointArgs $) {
        this.addresses = $.addresses;
        this.autoAddNewNodes = $.autoAddNewNodes;
        this.consistLevel = $.consistLevel;
        this.consistTimeout = $.consistTimeout;
        this.consistTimeoutAction = $.consistTimeoutAction;
        this.description = $.description;
        this.distributedTransaction = $.distributedTransaction;
        this.endpointId = $.endpointId;
        this.endpointName = $.endpointName;
        this.endpointType = $.endpointType;
        this.masterAcceptReadRequests = $.masterAcceptReadRequests;
        this.nodeIds = $.nodeIds;
        this.readWriteMode = $.readWriteMode;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(InstanceEndpointArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private InstanceEndpointArgs $;

        public Builder() {
            $ = new InstanceEndpointArgs();
        }

        public Builder(InstanceEndpointArgs defaults) {
            $ = new InstanceEndpointArgs(Objects.requireNonNull(defaults));
        }

        public Builder addresses(@Nullable Output<List<InstanceEndpointAddressArgs>> addresses) {
            $.addresses = addresses;
            return this;
        }

        public Builder addresses(List<InstanceEndpointAddressArgs> addresses) {
            return addresses(Output.of(addresses));
        }

        public Builder addresses(InstanceEndpointAddressArgs... addresses) {
            return addresses(List.of(addresses));
        }

        /**
         * @param autoAddNewNodes 是否允许自动加入新节点，取值：true：是。false：否。
         * 
         * @return builder
         * 
         */
        public Builder autoAddNewNodes(@Nullable Output<Boolean> autoAddNewNodes) {
            $.autoAddNewNodes = autoAddNewNodes;
            return this;
        }

        /**
         * @param autoAddNewNodes 是否允许自动加入新节点，取值：true：是。false：否。
         * 
         * @return builder
         * 
         */
        public Builder autoAddNewNodes(Boolean autoAddNewNodes) {
            return autoAddNewNodes(Output.of(autoAddNewNodes));
        }

        /**
         * @param consistLevel 一致性级别，仅对读写模式的连接终端有效。取值：Eventual：最终一致性。Session：会话一致性。Global：全局一致性。
         * 
         * @return builder
         * 
         */
        public Builder consistLevel(@Nullable Output<String> consistLevel) {
            $.consistLevel = consistLevel;
            return this;
        }

        /**
         * @param consistLevel 一致性级别，仅对读写模式的连接终端有效。取值：Eventual：最终一致性。Session：会话一致性。Global：全局一致性。
         * 
         * @return builder
         * 
         */
        public Builder consistLevel(String consistLevel) {
            return consistLevel(Output.of(consistLevel));
        }

        /**
         * @param consistTimeout 延迟很大时，只读节点同步最新数据的超时时间，单位为 us，取值范围为 1us~100000000us。
         * 
         * @return builder
         * 
         */
        public Builder consistTimeout(@Nullable Output<Integer> consistTimeout) {
            $.consistTimeout = consistTimeout;
            return this;
        }

        /**
         * @param consistTimeout 延迟很大时，只读节点同步最新数据的超时时间，单位为 us，取值范围为 1us~100000000us。
         * 
         * @return builder
         * 
         */
        public Builder consistTimeout(Integer consistTimeout) {
            return consistTimeout(Output.of(consistTimeout));
        }

        /**
         * @param consistTimeoutAction 只读节点同步数据超时后的超时策略，支持以下两种策略：ReturnError：返回 SQL 报错（wait replication complete timeout, please retry）。ReadMaster：发送请求到主节点。
         * 
         * @return builder
         * 
         */
        public Builder consistTimeoutAction(@Nullable Output<String> consistTimeoutAction) {
            $.consistTimeoutAction = consistTimeoutAction;
            return this;
        }

        /**
         * @param consistTimeoutAction 只读节点同步数据超时后的超时策略，支持以下两种策略：ReturnError：返回 SQL 报错（wait replication complete timeout, please retry）。ReadMaster：发送请求到主节点。
         * 
         * @return builder
         * 
         */
        public Builder consistTimeoutAction(String consistTimeoutAction) {
            return consistTimeoutAction(Output.of(consistTimeoutAction));
        }

        /**
         * @param description 地址描述。
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description 地址描述。
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param distributedTransaction 是否开启事务拆分，仅对读写模式的连接终端有效。取值：true：是。false：否。
         * 
         * @return builder
         * 
         */
        public Builder distributedTransaction(@Nullable Output<Boolean> distributedTransaction) {
            $.distributedTransaction = distributedTransaction;
            return this;
        }

        /**
         * @param distributedTransaction 是否开启事务拆分，仅对读写模式的连接终端有效。取值：true：是。false：否。
         * 
         * @return builder
         * 
         */
        public Builder distributedTransaction(Boolean distributedTransaction) {
            return distributedTransaction(Output.of(distributedTransaction));
        }

        /**
         * @param endpointId 实例连接终端 ID。
         * 
         * @return builder
         * 
         */
        public Builder endpointId(@Nullable Output<String> endpointId) {
            $.endpointId = endpointId;
            return this;
        }

        /**
         * @param endpointId 实例连接终端 ID。
         * 
         * @return builder
         * 
         */
        public Builder endpointId(String endpointId) {
            return endpointId(Output.of(endpointId));
        }

        /**
         * @param endpointName 实例连接终端名称。
         * 
         * @return builder
         * 
         */
        public Builder endpointName(@Nullable Output<String> endpointName) {
            $.endpointName = endpointName;
            return this;
        }

        /**
         * @param endpointName 实例连接终端名称。
         * 
         * @return builder
         * 
         */
        public Builder endpointName(String endpointName) {
            return endpointName(Output.of(endpointName));
        }

        /**
         * @param endpointType 连接终端类型，取值：Cluster：默认终端。Primary：主节点终端。Custom：自定义终端。
         * 
         * @return builder
         * 
         */
        public Builder endpointType(@Nullable Output<String> endpointType) {
            $.endpointType = endpointType;
            return this;
        }

        /**
         * @param endpointType 连接终端类型，取值：Cluster：默认终端。Primary：主节点终端。Custom：自定义终端。
         * 
         * @return builder
         * 
         */
        public Builder endpointType(String endpointType) {
            return endpointType(Output.of(endpointType));
        }

        /**
         * @param masterAcceptReadRequests 主节点是否接受读请求。仅对读写模式的连接终端有效。true：是。false：否。
         * 
         * @return builder
         * 
         */
        public Builder masterAcceptReadRequests(@Nullable Output<Boolean> masterAcceptReadRequests) {
            $.masterAcceptReadRequests = masterAcceptReadRequests;
            return this;
        }

        /**
         * @param masterAcceptReadRequests 主节点是否接受读请求。仅对读写模式的连接终端有效。true：是。false：否。
         * 
         * @return builder
         * 
         */
        public Builder masterAcceptReadRequests(Boolean masterAcceptReadRequests) {
            return masterAcceptReadRequests(Output.of(masterAcceptReadRequests));
        }

        /**
         * @param nodeIds 连接终端配置的节点列表。
         * 
         * @return builder
         * 
         */
        public Builder nodeIds(@Nullable Output<List<String>> nodeIds) {
            $.nodeIds = nodeIds;
            return this;
        }

        /**
         * @param nodeIds 连接终端配置的节点列表。
         * 
         * @return builder
         * 
         */
        public Builder nodeIds(List<String> nodeIds) {
            return nodeIds(Output.of(nodeIds));
        }

        /**
         * @param nodeIds 连接终端配置的节点列表。
         * 
         * @return builder
         * 
         */
        public Builder nodeIds(String... nodeIds) {
            return nodeIds(List.of(nodeIds));
        }

        /**
         * @param readWriteMode 连接终端的读写模式，取值：ReadWrite: 读写。ReadOnly: 只读。
         * 
         * @return builder
         * 
         */
        public Builder readWriteMode(@Nullable Output<String> readWriteMode) {
            $.readWriteMode = readWriteMode;
            return this;
        }

        /**
         * @param readWriteMode 连接终端的读写模式，取值：ReadWrite: 读写。ReadOnly: 只读。
         * 
         * @return builder
         * 
         */
        public Builder readWriteMode(String readWriteMode) {
            return readWriteMode(Output.of(readWriteMode));
        }

        public InstanceEndpointArgs build() {
            return $;
        }
    }

}
