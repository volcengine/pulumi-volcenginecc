// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.volcengine.volcenginecc.rdsmysql.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.volcengine.volcenginecc.rdsmysql.outputs.GetInstanceEndpointReadOnlyNodeWeight;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetInstanceEndpoint {
    /**
     * @return 当终端类型为读写终端或只读终端时，支持设置新节点是否自动加入。取值：Enable：自动加入Disable：不自动加入（默认）。
     * 
     */
    private String autoAddNewNodes;
    /**
     * @return 连接终端标签。
     * 
     */
    private List<String> connectionInfoTags;
    /**
     * @return 连接终端类型。取值：Proxy：代理终端。Direct：直连终端。
     * 
     */
    private String connectionMode;
    /**
     * @return 代理终端的连接池类型。取值：Transaction：事务级连接池。默认值。Direct：直连模式。
     * 
     */
    private String connectionPoolType;
    /**
     * @return 连接终端的描述信息。
     * 
     */
    private String description;
    /**
     * @return 是否启用连接保持。取值：true：是。false：否。
     * 
     */
    private Boolean enableConnectionPersistent;
    /**
     * @return 是否已开启全局只读，取值：Enable：开启。Disable：未开启。
     * 
     */
    private String enableReadOnly;
    /**
     * @return 是否已开启读写分离，取值：Enable：开启。Disable：未开启。
     * 
     */
    private String enableReadWriteSplitting;
    /**
     * @return 实例连接终端 ID。
     * 
     */
    private String endpointId;
    /**
     * @return 实例连接终端名称。
     * 
     */
    private String endpointName;
    /**
     * @return 终端类型。取值为 Custom，自定义终端。
     * 
     */
    private String endpointType;
    /**
     * @return 空闲连接回收功能是否开启。true：开启。false：不开启。
     * 
     */
    private Boolean idleConnectionReclaim;
    /**
     * @return 是否开启事务分离。取值：true：是。false：否。
     * 
     */
    private Boolean implicitTransSplit;
    /**
     * @return 是否开启主节点路由。取值：true：是。false：否。
     * 
     */
    private Boolean masterNodeRouting;
    /**
     * @return 过载保护超时时间。取值范围为 60~7200 之间的整数，单位为秒。
     * 
     */
    private Integer masterProtectorTimeout;
    /**
     * @return 代理终端的 Multi-Statements 模式。取值：Strict：Strict 模式。默认值。Loose：Loose 模式。
     * 
     */
    private String multiStatementsMode;
    /**
     * @return 是否开启过载保护。取值：true：是。false：否。
     * 
     */
    private Boolean overloadProtection;
    /**
     * @return 读权重分配模式。当开通读写分离设置为 true 时需要传入此参数。在 CreateDBEndpoint 和 ModifyDBEndpoint 接口中做请求参数时，取值范围如下：LoadSchedule：负载调度。RoundRobinCustom：自定义权重的轮询调度。RoundRobinAuto：自动分配权重的轮询调度。在 DescribeDBInstanceDetail 接口中做返回参数时，取值范围如下：Default：按规格权重自动分配。Custom：自定义分配权重。RoundRobin：轮询调度。LoadSchedule：负载调度。RoundRobinCustom：自定义权重的轮询调度。RoundRobinAuto：自动分配权重的轮询调度。
     * 
     */
    private String readOnlyNodeDistributionType;
    /**
     * @return 只读节点延迟阈值。取值范围为 1~3600，默认为 30，单位为秒。
     * 
     */
    private Integer readOnlyNodeMaxDelayTime;
    /**
     * @return 连接终端配置的节点列表及对应的只读权重。
     * 
     */
    private List<GetInstanceEndpointReadOnlyNodeWeight> readOnlyNodeWeights;
    /**
     * @return 读写模式：ReadWrite：读写。ReadOnly：只读。
     * 
     */
    private String readWriteMode;

    private GetInstanceEndpoint() {}
    /**
     * @return 当终端类型为读写终端或只读终端时，支持设置新节点是否自动加入。取值：Enable：自动加入Disable：不自动加入（默认）。
     * 
     */
    public String autoAddNewNodes() {
        return this.autoAddNewNodes;
    }
    /**
     * @return 连接终端标签。
     * 
     */
    public List<String> connectionInfoTags() {
        return this.connectionInfoTags;
    }
    /**
     * @return 连接终端类型。取值：Proxy：代理终端。Direct：直连终端。
     * 
     */
    public String connectionMode() {
        return this.connectionMode;
    }
    /**
     * @return 代理终端的连接池类型。取值：Transaction：事务级连接池。默认值。Direct：直连模式。
     * 
     */
    public String connectionPoolType() {
        return this.connectionPoolType;
    }
    /**
     * @return 连接终端的描述信息。
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return 是否启用连接保持。取值：true：是。false：否。
     * 
     */
    public Boolean enableConnectionPersistent() {
        return this.enableConnectionPersistent;
    }
    /**
     * @return 是否已开启全局只读，取值：Enable：开启。Disable：未开启。
     * 
     */
    public String enableReadOnly() {
        return this.enableReadOnly;
    }
    /**
     * @return 是否已开启读写分离，取值：Enable：开启。Disable：未开启。
     * 
     */
    public String enableReadWriteSplitting() {
        return this.enableReadWriteSplitting;
    }
    /**
     * @return 实例连接终端 ID。
     * 
     */
    public String endpointId() {
        return this.endpointId;
    }
    /**
     * @return 实例连接终端名称。
     * 
     */
    public String endpointName() {
        return this.endpointName;
    }
    /**
     * @return 终端类型。取值为 Custom，自定义终端。
     * 
     */
    public String endpointType() {
        return this.endpointType;
    }
    /**
     * @return 空闲连接回收功能是否开启。true：开启。false：不开启。
     * 
     */
    public Boolean idleConnectionReclaim() {
        return this.idleConnectionReclaim;
    }
    /**
     * @return 是否开启事务分离。取值：true：是。false：否。
     * 
     */
    public Boolean implicitTransSplit() {
        return this.implicitTransSplit;
    }
    /**
     * @return 是否开启主节点路由。取值：true：是。false：否。
     * 
     */
    public Boolean masterNodeRouting() {
        return this.masterNodeRouting;
    }
    /**
     * @return 过载保护超时时间。取值范围为 60~7200 之间的整数，单位为秒。
     * 
     */
    public Integer masterProtectorTimeout() {
        return this.masterProtectorTimeout;
    }
    /**
     * @return 代理终端的 Multi-Statements 模式。取值：Strict：Strict 模式。默认值。Loose：Loose 模式。
     * 
     */
    public String multiStatementsMode() {
        return this.multiStatementsMode;
    }
    /**
     * @return 是否开启过载保护。取值：true：是。false：否。
     * 
     */
    public Boolean overloadProtection() {
        return this.overloadProtection;
    }
    /**
     * @return 读权重分配模式。当开通读写分离设置为 true 时需要传入此参数。在 CreateDBEndpoint 和 ModifyDBEndpoint 接口中做请求参数时，取值范围如下：LoadSchedule：负载调度。RoundRobinCustom：自定义权重的轮询调度。RoundRobinAuto：自动分配权重的轮询调度。在 DescribeDBInstanceDetail 接口中做返回参数时，取值范围如下：Default：按规格权重自动分配。Custom：自定义分配权重。RoundRobin：轮询调度。LoadSchedule：负载调度。RoundRobinCustom：自定义权重的轮询调度。RoundRobinAuto：自动分配权重的轮询调度。
     * 
     */
    public String readOnlyNodeDistributionType() {
        return this.readOnlyNodeDistributionType;
    }
    /**
     * @return 只读节点延迟阈值。取值范围为 1~3600，默认为 30，单位为秒。
     * 
     */
    public Integer readOnlyNodeMaxDelayTime() {
        return this.readOnlyNodeMaxDelayTime;
    }
    /**
     * @return 连接终端配置的节点列表及对应的只读权重。
     * 
     */
    public List<GetInstanceEndpointReadOnlyNodeWeight> readOnlyNodeWeights() {
        return this.readOnlyNodeWeights;
    }
    /**
     * @return 读写模式：ReadWrite：读写。ReadOnly：只读。
     * 
     */
    public String readWriteMode() {
        return this.readWriteMode;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetInstanceEndpoint defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String autoAddNewNodes;
        private List<String> connectionInfoTags;
        private String connectionMode;
        private String connectionPoolType;
        private String description;
        private Boolean enableConnectionPersistent;
        private String enableReadOnly;
        private String enableReadWriteSplitting;
        private String endpointId;
        private String endpointName;
        private String endpointType;
        private Boolean idleConnectionReclaim;
        private Boolean implicitTransSplit;
        private Boolean masterNodeRouting;
        private Integer masterProtectorTimeout;
        private String multiStatementsMode;
        private Boolean overloadProtection;
        private String readOnlyNodeDistributionType;
        private Integer readOnlyNodeMaxDelayTime;
        private List<GetInstanceEndpointReadOnlyNodeWeight> readOnlyNodeWeights;
        private String readWriteMode;
        public Builder() {}
        public Builder(GetInstanceEndpoint defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.autoAddNewNodes = defaults.autoAddNewNodes;
    	      this.connectionInfoTags = defaults.connectionInfoTags;
    	      this.connectionMode = defaults.connectionMode;
    	      this.connectionPoolType = defaults.connectionPoolType;
    	      this.description = defaults.description;
    	      this.enableConnectionPersistent = defaults.enableConnectionPersistent;
    	      this.enableReadOnly = defaults.enableReadOnly;
    	      this.enableReadWriteSplitting = defaults.enableReadWriteSplitting;
    	      this.endpointId = defaults.endpointId;
    	      this.endpointName = defaults.endpointName;
    	      this.endpointType = defaults.endpointType;
    	      this.idleConnectionReclaim = defaults.idleConnectionReclaim;
    	      this.implicitTransSplit = defaults.implicitTransSplit;
    	      this.masterNodeRouting = defaults.masterNodeRouting;
    	      this.masterProtectorTimeout = defaults.masterProtectorTimeout;
    	      this.multiStatementsMode = defaults.multiStatementsMode;
    	      this.overloadProtection = defaults.overloadProtection;
    	      this.readOnlyNodeDistributionType = defaults.readOnlyNodeDistributionType;
    	      this.readOnlyNodeMaxDelayTime = defaults.readOnlyNodeMaxDelayTime;
    	      this.readOnlyNodeWeights = defaults.readOnlyNodeWeights;
    	      this.readWriteMode = defaults.readWriteMode;
        }

        @CustomType.Setter
        public Builder autoAddNewNodes(String autoAddNewNodes) {
            if (autoAddNewNodes == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "autoAddNewNodes");
            }
            this.autoAddNewNodes = autoAddNewNodes;
            return this;
        }
        @CustomType.Setter
        public Builder connectionInfoTags(List<String> connectionInfoTags) {
            if (connectionInfoTags == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "connectionInfoTags");
            }
            this.connectionInfoTags = connectionInfoTags;
            return this;
        }
        public Builder connectionInfoTags(String... connectionInfoTags) {
            return connectionInfoTags(List.of(connectionInfoTags));
        }
        @CustomType.Setter
        public Builder connectionMode(String connectionMode) {
            if (connectionMode == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "connectionMode");
            }
            this.connectionMode = connectionMode;
            return this;
        }
        @CustomType.Setter
        public Builder connectionPoolType(String connectionPoolType) {
            if (connectionPoolType == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "connectionPoolType");
            }
            this.connectionPoolType = connectionPoolType;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder enableConnectionPersistent(Boolean enableConnectionPersistent) {
            if (enableConnectionPersistent == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "enableConnectionPersistent");
            }
            this.enableConnectionPersistent = enableConnectionPersistent;
            return this;
        }
        @CustomType.Setter
        public Builder enableReadOnly(String enableReadOnly) {
            if (enableReadOnly == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "enableReadOnly");
            }
            this.enableReadOnly = enableReadOnly;
            return this;
        }
        @CustomType.Setter
        public Builder enableReadWriteSplitting(String enableReadWriteSplitting) {
            if (enableReadWriteSplitting == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "enableReadWriteSplitting");
            }
            this.enableReadWriteSplitting = enableReadWriteSplitting;
            return this;
        }
        @CustomType.Setter
        public Builder endpointId(String endpointId) {
            if (endpointId == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "endpointId");
            }
            this.endpointId = endpointId;
            return this;
        }
        @CustomType.Setter
        public Builder endpointName(String endpointName) {
            if (endpointName == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "endpointName");
            }
            this.endpointName = endpointName;
            return this;
        }
        @CustomType.Setter
        public Builder endpointType(String endpointType) {
            if (endpointType == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "endpointType");
            }
            this.endpointType = endpointType;
            return this;
        }
        @CustomType.Setter
        public Builder idleConnectionReclaim(Boolean idleConnectionReclaim) {
            if (idleConnectionReclaim == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "idleConnectionReclaim");
            }
            this.idleConnectionReclaim = idleConnectionReclaim;
            return this;
        }
        @CustomType.Setter
        public Builder implicitTransSplit(Boolean implicitTransSplit) {
            if (implicitTransSplit == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "implicitTransSplit");
            }
            this.implicitTransSplit = implicitTransSplit;
            return this;
        }
        @CustomType.Setter
        public Builder masterNodeRouting(Boolean masterNodeRouting) {
            if (masterNodeRouting == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "masterNodeRouting");
            }
            this.masterNodeRouting = masterNodeRouting;
            return this;
        }
        @CustomType.Setter
        public Builder masterProtectorTimeout(Integer masterProtectorTimeout) {
            if (masterProtectorTimeout == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "masterProtectorTimeout");
            }
            this.masterProtectorTimeout = masterProtectorTimeout;
            return this;
        }
        @CustomType.Setter
        public Builder multiStatementsMode(String multiStatementsMode) {
            if (multiStatementsMode == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "multiStatementsMode");
            }
            this.multiStatementsMode = multiStatementsMode;
            return this;
        }
        @CustomType.Setter
        public Builder overloadProtection(Boolean overloadProtection) {
            if (overloadProtection == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "overloadProtection");
            }
            this.overloadProtection = overloadProtection;
            return this;
        }
        @CustomType.Setter
        public Builder readOnlyNodeDistributionType(String readOnlyNodeDistributionType) {
            if (readOnlyNodeDistributionType == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "readOnlyNodeDistributionType");
            }
            this.readOnlyNodeDistributionType = readOnlyNodeDistributionType;
            return this;
        }
        @CustomType.Setter
        public Builder readOnlyNodeMaxDelayTime(Integer readOnlyNodeMaxDelayTime) {
            if (readOnlyNodeMaxDelayTime == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "readOnlyNodeMaxDelayTime");
            }
            this.readOnlyNodeMaxDelayTime = readOnlyNodeMaxDelayTime;
            return this;
        }
        @CustomType.Setter
        public Builder readOnlyNodeWeights(List<GetInstanceEndpointReadOnlyNodeWeight> readOnlyNodeWeights) {
            if (readOnlyNodeWeights == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "readOnlyNodeWeights");
            }
            this.readOnlyNodeWeights = readOnlyNodeWeights;
            return this;
        }
        public Builder readOnlyNodeWeights(GetInstanceEndpointReadOnlyNodeWeight... readOnlyNodeWeights) {
            return readOnlyNodeWeights(List.of(readOnlyNodeWeights));
        }
        @CustomType.Setter
        public Builder readWriteMode(String readWriteMode) {
            if (readWriteMode == null) {
              throw new MissingRequiredPropertyException("GetInstanceEndpoint", "readWriteMode");
            }
            this.readWriteMode = readWriteMode;
            return this;
        }
        public GetInstanceEndpoint build() {
            final var _resultValue = new GetInstanceEndpoint();
            _resultValue.autoAddNewNodes = autoAddNewNodes;
            _resultValue.connectionInfoTags = connectionInfoTags;
            _resultValue.connectionMode = connectionMode;
            _resultValue.connectionPoolType = connectionPoolType;
            _resultValue.description = description;
            _resultValue.enableConnectionPersistent = enableConnectionPersistent;
            _resultValue.enableReadOnly = enableReadOnly;
            _resultValue.enableReadWriteSplitting = enableReadWriteSplitting;
            _resultValue.endpointId = endpointId;
            _resultValue.endpointName = endpointName;
            _resultValue.endpointType = endpointType;
            _resultValue.idleConnectionReclaim = idleConnectionReclaim;
            _resultValue.implicitTransSplit = implicitTransSplit;
            _resultValue.masterNodeRouting = masterNodeRouting;
            _resultValue.masterProtectorTimeout = masterProtectorTimeout;
            _resultValue.multiStatementsMode = multiStatementsMode;
            _resultValue.overloadProtection = overloadProtection;
            _resultValue.readOnlyNodeDistributionType = readOnlyNodeDistributionType;
            _resultValue.readOnlyNodeMaxDelayTime = readOnlyNodeMaxDelayTime;
            _resultValue.readOnlyNodeWeights = readOnlyNodeWeights;
            _resultValue.readWriteMode = readWriteMode;
            return _resultValue;
        }
    }
}
